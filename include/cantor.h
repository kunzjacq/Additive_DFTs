#pragma once

#include <vector>
#include <iostream>
#include <chrono>
#include <bitset>
#include <cmath>

#include <cstdint>

#include "defs.h"

using namespace std;
using namespace std::chrono;


#ifdef Boost_FOUND
#include <boost/multiprecision/cpp_int.hpp>

using namespace boost::multiprecision;
using namespace boost::multiprecision::literals;

typedef number<cpp_int_backend<2048, 2048, unsigned_magnitude, unchecked, void> > uint2048_t;
BOOST_MP_DEFINE_SIZED_CPP_INT_LITERAL(2048)

#define HAS_UINT128
#define HAS_UINT256
#define HAS_UINT512
#define HAS_UINT1024
#define HAS_UINT2048
#else
typedef __uint128_t uint128_t;
ostream& operator << (ostream& os, const uint128_t& v);
#endif

typedef unsigned int base_index;

/**
 * cantor_basis<word> : a class defining a finite field of size 2**n if n = 8 * sizeof(word).
 * word can be uintX_t, with X = 2**3...10. for sizes above uint64_t, boost::multiprecision large
 * integers are used. Two bases are used for operations on elements.
 * The field is build as sucessive degree 2 extensions, this is why only sizes of the form 2**k
 * with k a power of 2 can be obtained.
 * The most efficient element representation uses a basis gamma_i where if i = sum_k 2**{j_k},
 * j_k pairwise distinct, gamma_i = product_k gamma_{2**{j_k}}.
 * the gamma_{2**j} have degree 2 over the field generated by gamma_{2**k}, k < j, which is the
 * same as the f2-vector space generated by the gamma_{l}, l < 2**j.
 *
 * A word w describing an element can be efficiently decomposed into a + gamma_{2**(n-1)} * b
 * where a and b are in the degree 2 subfield: a and b are just halves of w.
 * This enables one to compute products as subproducts in the degree 2 subfield. this is the method
 * used to speed up multiplication using a logarithm/exponent table in a small subfield.
 *
 * The actual Cantor basis {beta_i} is related to {gamma_i} as follows:
 * for all i, beta_{2**i} = gamma_{2**i}
 * for all j > 0, beta_{2**i}**2 = beta_{2**i} + beta_{2**i - 1}.
 * methods are provided to go from one representation to another.
 *
 * It is not straightforward to multiply efficiently elements in beta representation, because
 * unlike the gamma representation, given a word of element coefficients w on {beta_i}, halves
 * of w do not correspond to a representation a + gamma_{2**(n-1)} * b with a and b in
 * the degree 2 subfield.
 */

/**
 * Various templated functions useful to the main code, defined in helpers.cpp
 */
template<class word> unsigned int bit(const word &w, unsigned int idx);
template<class word> void set_bit(word &w, unsigned int idx, int bit_val);
template<class word> void xor_bit(word &w, unsigned int idx, int bit_val);
template<class word> unsigned int popcnt_mod_2(const word &w, unsigned int n = 0);
template<class word> unsigned int bit_cppinteger(const word &w, unsigned int idx);
template<class word> void set_bit_cppinteger(word &w, unsigned int idx, int bit_val);
template<class word> void xor_bit_cppinteger(word &w, unsigned int idx, int bit_val);
template<class word> unsigned int popcnt_mod_2_cppinteger(const word &w, unsigned int n);

/**
 * A class that defines dependent types for class cantor_basis.
 * It should be incorporated into class cantor_basis itself, but it does not seem feasible
 * to do so without duplicating the common part for each template type.
*/

template<class word> class c_b_t
{};

template<>
class c_b_t<uint8_t>{
public:
  static constexpr unsigned int word_logsize = 3;
  static constexpr unsigned int n = 8;
  static constexpr uint8_t u = 1;
  typedef uint8_t log_type;
  typedef uint8_t half_type;
  typedef uint8_t random_type;
};

template<>
class c_b_t<uint16_t>{
public:
  static constexpr unsigned int word_logsize = 4;
  static constexpr unsigned int n = 16;
  static constexpr uint16_t u = 1;
  typedef uint16_t log_type;
  typedef uint8_t half_type;
  typedef uint16_t random_type;
};

template<>
class c_b_t<uint32_t>{
public:
  static constexpr unsigned int word_logsize = 5;
  static constexpr unsigned int n = 32;
  static constexpr uint32_t u = 1;
  typedef uint16_t log_type;
  typedef uint16_t half_type;
  typedef uint32_t random_type;
};

template<>
class c_b_t<uint64_t>{
public:
  static constexpr unsigned int word_logsize = 6;
  static constexpr int unsigned n = 64;
  static constexpr uint64_t u = 1;
  typedef uint16_t log_type;
  typedef uint32_t half_type;
  typedef uint64_t random_type;
 };

#ifdef HAS_UINT128
template<>
class c_b_t<uint128_t>
{
public:
  static constexpr unsigned int word_logsize = 7;
  static constexpr int unsigned n = 128;
  static constexpr uint128_t u = 0x1_cppui128;
  typedef uint16_t log_type;
  typedef uint64_t half_type;
  typedef uint64_t random_type;
};
#endif

#ifdef HAS_UINT256
template<>
class c_b_t<uint256_t>
{
public:
  static constexpr unsigned int word_logsize = 8;
  static constexpr int unsigned n = 256;
  static constexpr uint256_t u = 0x1_cppui256;
  typedef uint16_t log_type;
  typedef uint128_t half_type;
  typedef uint64_t random_type;
};
#endif

#ifdef HAS_UINT512
template<>
class c_b_t<uint512_t>{
public:
  static constexpr unsigned int word_logsize = 9;
  static constexpr int unsigned n = 512;
  static constexpr uint512_t u = 0x1_cppui512;
  typedef uint16_t log_type;
  typedef uint256_t half_type;
  typedef uint64_t random_type;
};
#endif

#ifdef HAS_UINT1024
template<>
class c_b_t<uint1024_t>{
public:
  static constexpr unsigned int word_logsize = 10;
  static constexpr int unsigned n = 1024;
  static constexpr uint1024_t u = 0x1_cppui1024;
  typedef uint16_t log_type;
  typedef uint512_t half_type;
  typedef uint64_t random_type;
};
#endif

#ifdef HAS_UINT2048
template<>
class c_b_t<uint2048_t>{
public:
  static constexpr unsigned int word_logsize = 11;
  static constexpr int unsigned n = 2048;
  static constexpr uint2048_t u = 0x1_cppui2048;
  typedef uint16_t log_type;
  typedef uint1024_t half_type;
  typedef uint64_t random_type;
};
#endif

class time_measurements
{
public:
  double m_linear_algebra_time;
  double m_generator_decomposition_time;
  double m_log_computation_time;
  double m_reuse_time;
  time_measurements():
    m_linear_algebra_time(0),
    m_generator_decomposition_time(0),
    m_log_computation_time(0),
    m_reuse_time(0){}
  double linalg_time() const{return m_linear_algebra_time;}
  double gendec_time() const{return m_generator_decomposition_time;}
  double logcomp_time() const{return m_log_computation_time;}
  double reuse_time() const{return m_reuse_time;}
};

/**
 * Cantor basis implementation for large field sizes.
 * Contrary to cantor_basis_full, the full multiplication table gamma_i * gamma_j is not computed.
 * only the gamma_i**2 and the beta_i are computed.
 * Construction is recursive, but data is represented in a 'flat' manner and smaller objects are
 * not memorized. This simplifies the code, but twice more memory is used because
 * the triangular nature of the matrices for gamma_i**2 and beta_i of gamma_i is not leveraged
 * to reduce memory usage.
 */

constexpr unsigned int mult_mul_table_logsize=16;

template<class word>
class cantor_basis_bare
{
private:
  // m_beta_over_gamma[j] = coefficients of beta_j on gamma basis
  // if j is a power of 2, beta_j = gamma_j
  // otherwise, gamma_j = product for i in S of gamma_2**i where i in S if bit i of j is set
  word* m_beta_over_gamma;
  word* m_gamma_over_beta;
  word* m_beta_to_gamma_table;
  word* m_gamma_to_beta_table;

  word* m_mult_over_gamma;
  word* m_gamma_over_mult;
  word* m_mult_to_gamma_table;
  word* m_gamma_to_mult_table;

  word* m_mult_mul_table;
  word* m_beta_to_mult_table;

  word mult_generator_minimal_polynomial;

  word* m_masks;
  word* m_gamma_squares;
  uint32_t m_log_table_sizes;
  uint32_t m_order;
  bool m_log_computed;
  typename c_b_t<word>::log_type* m_log;
  typename c_b_t<word>::log_type* m_exp;
  typename c_b_t<word>::log_type* m_log_beta;
  typename c_b_t<word>::log_type* m_exp_beta;
  word* m_A;  //to store a temporary matrix
  word* m_AA; //to store a temporary matrix
  time_measurements m_t;
  mutable int m_error;

public:
  cantor_basis_bare();
  ~cantor_basis_bare();

  typename c_b_t<word>::log_type*& log_table() {return m_log;}
  typename c_b_t<word>::log_type*& exp_table() {return m_exp;}
  typename c_b_t<word>::log_type*& beta_log_table() {return m_log_beta;}
  typename c_b_t<word>::log_type*& beta_exp_table() {return m_exp_beta;}

  // methods common to cantor_basis_bare and cantor_basis_full
  // these methods work on gamma representation.
  word multiply(const word &a, const word &b) const;
  word square(const word &a) const;
  word inverse(const word& a) const;
  word multiply_safe(const word &a, const word &b) const;
  word square_safe(const word &a) const;

  word beta_over_gamma(unsigned int i) const;
  word gamma_to_beta(const word& w) const;
  word beta_to_mult(const word& w) const;
  word gamma_over_beta(unsigned int i) const;
  word beta_to_gamma(const word& w, unsigned int num_bytes = 0) const;

  word mult_over_gamma(unsigned int i) const;
  word gamma_to_mult(const word& w) const;
  word gamma_over_mult(unsigned int i) const;
  word mult_to_gamma(const word& w, unsigned int num_bytes = 0) const;

  template<int> word beta_to_gamma_byte(uint32_t v) const;
  word trace(const word& w) const;
  word gamma_square(unsigned int i) const { return m_gamma_squares[i]; }
  word multiply_beta_repr_ref(const word &a, const word &b) const;

  word multiply_mult_repr_ref(const word &a, const word &b) const;
  word multiply_mult_repr(const word &a, const word &b) const;

  int error() const;
  time_measurements times(){return m_t;}
  static constexpr bool has_ref_product() { return false; }

  // methods specific to cantor_basis_bare

private:
  void build_from_subfield();
  void prepare_square_matrix(unsigned int i);
  void build();
  void test_cache();
private:
  void free_memory();
};


/**
 * Cantor basis implementation for small field sizes.
 * Builds the full multiplication table gamma_i * gamma_j for all i,j,
 * and the beta_i using linear algebra.
 * multiplications in the field can be computed either directly with the gamma products table
 * (which is slow, but serves as a reference implementation)
 * or using recursive degree-2 decompositions.
 * see multiply_ref and multiply.
 */

template<class word>
class cantor_basis_full
{
public:
  cantor_basis_full();
  ~cantor_basis_full();
  //void prepare_square_matrix(unsigned int i);

  typename c_b_t<word>::log_type*& log_table() {return m_log;}
  typename c_b_t<word>::log_type*& exp_table() {return m_exp;}
  typename c_b_t<word>::log_type*& beta_log_table() {return m_log_beta;}
  typename c_b_t<word>::log_type*& beta_exp_table() {return m_exp_beta;}

  // methods common to cantor_basis_bare and cantor_basis_full
  word multiply(const word& a, const word& b) const;
  word square(const word& a) const;
  word inverse(const word& a) const;
  word multiply_safe(const word &a, const word &b) const;
  word square_safe(const word &a) const;

  word beta_over_gamma(unsigned int i) const; // i < n
  word gamma_to_beta(const word& w) const;
  word gamma_over_beta(unsigned int i) const; // i < n
  word beta_to_gamma(const word& w, unsigned int num_bytes = 0) const;

  word mult_over_gamma(unsigned int i) const;
  word gamma_to_mult(const word& w) const;
  word gamma_over_mult(unsigned int i) const;
  word mult_to_gamma(const word& w, unsigned int num_bytes = 0) const;

  template<int> word beta_to_gamma_byte(uint32_t v) const;
  word trace(const word& w) const;
  // returns gamma_i**2
  word gamma_square(unsigned int i) const;
  word multiply_beta_repr_ref(const word &a, const word &b) const;

  int error() const{return m_error;}
  time_measurements times(){return m_t;}
  static constexpr bool has_ref_product(){return true;}

  // methods specific to cantor_basis_full
  word multiply_beta_repr(const word& a, const word& b) const;
  word multiply_ref(const word &a, const word &b, const unsigned int nprime = 0) const;
  word square_ref(const word &a) const;

private:
  void gamma_step(unsigned int i);
  void create_log_exp_tables();

  word* m_beta_over_gamma;
  word* m_gamma_over_beta;
  word* m_beta_to_gamma_table;
  word* m_gamma_to_beta_table;

  word* m_mult_over_gamma;
  word* m_gamma_over_mult;
  word* m_mult_to_gamma_table;
  word* m_gamma_to_mult_table;

  word* m_masks;
  word* m_A;  //to store a matrix
  word* m_AA; //to store a matrix
  bool m_log_computed;
  uint32_t m_log_table_sizes;
  uint32_t m_order;
  typename c_b_t<word>::log_type* m_log;
  typename c_b_t<word>::log_type* m_exp;
  typename c_b_t<word>::log_type* m_log_beta;
  typename c_b_t<word>::log_type* m_exp_beta;
  time_measurements m_t;
  word* m_gamma_products;
  word* m_beta_gamma_products;
  int* m_product_unique_index;
  mutable vector<bool> m_ref_product_bits;
  vector<int> m_num_distinct_products;
  mutable int m_error;

  word g_square(base_index base_square, int topmost_bit) const;
  word g_product(base_index g1, base_index g2, int top_bit_square_index) const;
  word mult_gen(unsigned int i, const word &v, int top_sq_bit_index) const;
  typename c_b_t<word>::log_type multiply_w_log(typename c_b_t<word>::log_type a, typename c_b_t<word>::log_type b) const;
  typename c_b_t<word>::log_type square_w_log(typename c_b_t<word>::log_type a) const;
};

template<class word>
class cantor_basis:public cantor_basis_bare<word> {
};

template<>
class cantor_basis<uint8_t>: public cantor_basis_full<uint8_t> {
};

template<>
class cantor_basis<uint16_t>: public cantor_basis_full<uint16_t> {
};


template<class word>
void print_row(const word& w, unsigned int nprime=0)
{
  const unsigned int n = nprime == 0 ? c_b_t<word>::n : nprime;
  for(unsigned int j = 0 ; j < n; j++)
  {
    cout << (((w >> j) & 1) ? "1" : " ");
  }
  cout << "|" << endl;
}

template<class word>
void print_matrix(word *A, unsigned int nprime=0)
{
  const unsigned int n = nprime == 0 ? c_b_t<word>::n : nprime;
  for(unsigned int i = 0; i < n; i++)
  {
    cout << hex << setw((c_b_t<word>::word_logsize+3) >> 2) << i << ": ";
    print_row(A[i], n);
  }
}

#ifdef HAS_UINT2048
extern template class cantor_basis_bare<uint2048_t>;
extern template class cantor_basis<uint2048_t>;
#endif
#ifdef HAS_UINT1024
extern template class cantor_basis_bare<uint1024_t>;
extern template class cantor_basis<uint1024_t>;
#endif
#ifdef HAS_UINT512
extern template class cantor_basis_bare<uint512_t>;
extern template class cantor_basis<uint512_t>;
#endif
#ifdef HAS_UINT256
extern template class cantor_basis_bare<uint256_t>;
extern template class cantor_basis<uint256_t>;
#endif

#ifdef HAS_UINT128
extern template class cantor_basis_bare<uint128_t>;
extern template class cantor_basis<uint128_t>;
#endif

extern template class cantor_basis_bare<uint64_t>;
extern template class cantor_basis<uint64_t>;

extern template class cantor_basis_bare<uint32_t>;
extern template class cantor_basis<uint32_t>;

extern template class cantor_basis_full<uint16_t>;
extern template class cantor_basis<uint16_t>;

extern template class cantor_basis_full<uint8_t>;
extern template class cantor_basis<uint8_t>;
