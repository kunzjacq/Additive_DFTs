version récursive

entrée : s >=0, f polynôme de degré < eta, eta = 2**(2*t), t = 2**s, j et omega_j = somme_{i>=0} eps_i beta_i avec j = somme_{i>=0} eps_i 2**i. (en pratique j et w_j se confondent dans le code).

(si l'on provient d'un appel récursif de plus haut niveau, f représente le polynôme initial modulo x**eta - x - w_j.eta, qui est linéaire et coincide avec f sur 
w_{j.eta}, ..., w_{j.eta+eta-1})

(et peut-etre : stride entrée, stride sortie si pas en place, facteur de parallélisme. En général facteur de // = stride. La même interface doit être utilisée pour la fonction de décomposition de taylor.).

sortie : dans un tableau de taille eta : {f(w_{j.eta}), f(w_{j.eta+1}), ..., f(w_{j.(eta+1)-1})} = evaluation de f sur w_{j.eta} + W_t

mais certainement pour gérer la récursivité le plus simple est de travailler en place de procéder entièrement par effet de bord.

algorithme :

idée : on note Q_u = X**u -X pour tout u.
eta = 2**T, T = 2**S;
tau = 2**t, t = 2**(s-1). (eta = tau**2 = 2**{2*t}, T = 2*t) 

la décomposition Q_eta (X - b) = Q_eta(X) - Q_eta(b) = Prod_{a \in W_t} (Q_{tau}(X) - Q_{tau}(b) - a)

nous donne une correspondance entre à gauche les valeurs d'un polynôme f sur W_{2*t} + b, b = 2**{2*t} j, 
(qui sont les mêmes que celles de f modulo le polynôme de gauche) 
et les valeurs de f sur les espaces W_t + b + 2**t a, a valeur de t bits.  avec la notation omega de Mateer:

Q_eta - w_j = Prod_{k < 2**t} (Q_{tau}(X)  - w_{2**t j + k})

ou encore

Q_eta(X - w_{2**{2t} j}) = Prod_{k < 2**t} (Q_{tau}(X - w_{2**{2*t} * j + 2**t * k}))

on évalue récursivement la FFT en calculant les f mod les polynômes de droite et en faisant une fft sur chacun des polynômes obtenus.

on ne fait pas les calculs des f mod R_i = Q_{tau}(X)  - w_{2**t j + i} pour i < 2**t indépendamment. On procède plutôt comme suit :

on décompose d'abord f sous la forme

f(x) = somme_{\ell<tau} f_{\ell}(x) (Q_tau)**{\ell} avec deg f_{ell} < tau

alors comme R_i = Q_tau - w_{2**t j + i}, 

f mod R_i = somme_{\ell<tau} f_{\ell}(x) w_{2**t j + i}**{\ell}.

autrement dit, f mod R_k est une fft du polynôme en y somme_{i<tau} f_i(x) y**i, sur l'espace W_t + w_{2**t j}. le fait que les coefficients du polynôme soient eux-même des polynômes n'est pas un problème : on la décompose en tau fft suivant les degrés en x et on recompose le polynôme final.


tout cela donne en pratique l'algorithme suivant :

------------------------------------------

si eta = 2 (ie t = 1, s = 0), calcul direct (u = f_0+w_2.j, f_0 + w_2.j+1 = f_0 +w_2.j + 1 = u + 1)

sinon, s > 0 :
1) décomposition de f suivant x**tau -x, tau = 2**t = sqrt(eta)

f(x) = somme_{i<tau} f_i(x) (x**tau - x)**i avec deg f_i < tau, soit
f(x) = g(x, x**tau-x) avec 
g(x,y) = somme_{i < tau} f_i(x) y**i.
       = somme_{i < tau, k < tau} f_i_k x**k y**i,   f_i_k = coeff de degré k de f_i

écriture des coeff des f_i en ligne dans matrice carrée (ligne 0 = f_0, ligne 1 = f_1 etc).

2) effectuer tau fft des colonnes pour obtenir les valeurs des polynômes correspondants dans  W_t + w_{j.tau} (tau = 2**t) ; i.e. tau appels récursifs avec s - 1, les coeffs, j.

avant la fft, la colonne k contient le polynôme en y 

P_k = somme_{i < tau} f_i_k y**i

après la fft, la colonne k, ligne i contient somme_{\ell < tau} f_\ell_k w{j.tau + i}**{\ell}

la ligne i représente donc le polynôme 

somme{k<tau} (somme_{\ell < tau} f_\ell_k w{j.tau + i}**\ell) x**k =
somme_{\ell < tau} f_{\ell} w{j.tau + i}**{\ell} 

soit f mod R_i.

3) effectuer les fft des lignes, soit pour tout i < tau la fft de f mod R_i  sur W_t + w_{2**{2*t} * j + 2**t * i}.

Sur la ligne i, on appelle donc récursivement l'algorithme avec, outre les coefficients de la ligne, les paramètres s-1 et r_i = j.2**t + i.

Comme la i-ième fft fournit les valeurs de f sur W_t + w_{2**{2*t} * j + 2**t * i}, si la matrice est par lignes en mémoire, les valeurs sont déjà dans le bon ordre pour le retour final des W_{2*t} + w_{2**{2*t} *j + k}, k = 0... 2**{2*t} - 1.

--------------------------

séquence des sous-appels effectués

void fft(word* poly, int s, word j, unsigned int logstride)
{
if(s==0)
{
uint64_t stride = 1uL << logstride;
for(uint64_t i = 0; i < stride; i++)
{
    poly[i] = poly[i] ^ multiply(poly[i + stride], j << 1);
	poly[i+stride] = poly[i] ^ poly[i + stride];
	//(u = f_0 + f1* w_{2.j}, f_0 + f1 * w_{2.j+1} = f_0 + f1 *(w_{2.j} + 1) = u + f_1)
}
}
else
{
unsigned int t   = 1uL << (s-1);
uint64_t eta = 1uL << (2*t);
uint64_t tau = 1uL << t;
decompose_taylor(poly, tau, logstride);
fft(poly, s-1, j, logstride + t);
for(uint64_t i = 0; i < tau; i++)
{
fft(poly+(tau<<logstride), s-1, (j<<t)|i, logstride);
}
}
}


